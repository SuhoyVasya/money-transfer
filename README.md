1)
	CPU загружен  в среднем на 20%.
	Потребление памяти в среднем 88МБ.	
	Среднее время выполнения запроса 0.175 с, за 10 минут увеличилось в 5 раз.
	Утечки памяти не обнаружены.
	С помощью инструмента Sampler выявлено что самый затратный по процессорному времени метод AccountDAOImpl.getAllAccounts(). Делаю Snapshot и анализируя стеки вызовов вижу что этот метод вызывается из метода AccountDAOImpl.getAccountByUser(). Выгрузка всех записей аккаунтов для того чтобы получить одну - ошибка. Исправляю метод AccountDAOImpl.getAccountByUser() чтобы он выгружал из БД записи с нужными именами. Из кода видно что метод AccountDAOImpl.getAllAccounts() возвращает HashSet, притом метод Account.hashCode() раелизован неправильно. Исправляю его в первом приближении: будет вместо 1 возвращать id аккаунта приведеный к типу данных int.


2)	CPU загружен  в среднем на 13%.
	Потребление памяти в среднем 66МБ.	
	Среднее время выполнения запроса 0.064с, за 10 минут увеличилось до 0.085с.
	Утечки памяти не обнаружены.
	С помощью Sampler выявляю что теперь самый затратный по процессорному времени метод AccountService.getAllAccounts() и UserService.getAllUsers(). Из кода видно что метод UserDAOImpl.getAllUsers() возвращает ArrayList. Он дает преимущество при операциях с произвольным доступом к элементам. В нашем случае целесообразнее заменить его на LinkedList. Возможно есть смысл также переписать метод AccountDAOImpl.getAllAccounts() так чтобы он тоже выдавал LinkedList(). Способ создания аккаунтов исключает дубликаты, а  HashSet имеет намного большие накладные расходы быстродействия чем LinkedList. Плюс нам нет необходимости в произвольном доступе к элементам. Практические тесты показали что предположения с заменой типа коллекции, возвращаемой UserDAOImpl.getAllUsers(), не оправдываются.  
	Оба метода AccountService.getAllAccounts() и UserService.getAllUsers() используют Stream API для преобразования коллекции из объектов Acount и User к строке. При заведомо малых колличествах элементов в этих коллекциях(~10000) целесообразнее получать эту строку через StringBuilder и Iterator. Пример функции преобразующей коллекцию в строку написан и заккоментирован в конце файла AccountService.java. Изменения в программе не производились.
	В классе UserDAOImpl есть поле fetched, представляющее собой ArrayList. В процессе работы коллекция постоянно пополняется и нигде не используется, это может спровоцировать утечку памяти. Поле закоментировано.
	


3) 	CPU загружен  в среднем на 9%.
	Потребление памяти в среднем 33МБ.	
	Среднее время выполнения запроса 0.056с, за 10 минут увеличилось до 0.079с.
	Утечки памяти не обнаружены.
Инструмент Sampler показывает что самые загруженные методы по-прежнему AccountService.getAllAccounts() и UserService.getAllUsers(). Их оптимизировать уже некуда, а оптимизация других методов существенного прироста быстродействия не даст. Дальше буду искать ошибки в коде без использования профилировщика.
	Метод UserDAOImpl.ginsetUser() использует sql запрос для получения всех пользователей чтобы впоследствии выбрать из них пользователя с максимальным id. Чтобы избежать этого лучше сделать в БД AUTO_INCREMENT на UserId в таблице User. Но в файле demo.sql написано DO NOT CHANGE. Поэтому найдем максимальный id отдельным sql запросом.
	В классе UserService есть поле allUsers, представляющее собой ArrayList. В процессе работы коллекция постоянно пополняется и нигде не используется, это может спровоцировать утечку памяти. Поле закоментировано.
	Метод UserService.getUserImage() работает неоптимально. Я его переписал чтобы он получал из файла сразу массив байт а не подгружал по одному.


4) 	Итоговый замер
   	CPU загружен  в среднем на 9%.
	Потребление памяти в среднем 33МБ.	
	Среднее время выполнения запроса 0.056с, за 10 минут увеличилось до 0.079с.
	Утечки памяти не обнаружены.


5) 	Рассматривается работа 4 видов GC: Serial, Parallel, CMS, G1. Их оценка будет даваться следующим способом: запуск программы в условиях жесткого ограничения размера кучи и замер времени жизни программы и количества обработанных запросов. При ограничении памяти сборщик мусора начинает отбирать у программы больше ресурсов на свою работу и это влияет на количество обработанных запросов. Результаты получились следующие:

  	GC		Uptime(m.s)			Requests
	1)SerialGC	6.48				1791
	2)ParallelGC	3.13				1084
	3)CMSGC		7.05				1663
	4)G1GC		6.27				1599

	Результат, полученный SerialGC можно исключить так как он имел заведомое преимущество изза малого требования к памяти и ресурсам. Oracle рекомендует использовать его только в случаях с приложениями, для которых нужен малый объем памяти.
	Из остальных самым подходящим является CMS.

6) Добавлены классы реализующие все функции на основе HashMap
	Результаты:
	CPU загружен  в среднем на 7%.
	Потребление памяти в среднем 15МБ.	
	Среднее время выполнения запроса 0.052с, за 10 минут увеличилось до 0.068с.
	Утечки памяти не обнаружены.



